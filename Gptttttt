import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;

public class LatencyBasedLoadBalancerTest {

    public static void main(String[] args) throws InterruptedException {
        LatencyBasedLoadBalancer lb = new LatencyBasedLoadBalancer(10); // 10 секунд окно

        // Добавим хосты
        lb.addHost("10.0.0.1");
        lb.addHost("10.0.0.2");
        lb.addHost("10.0.0.3");

        // Имитируем latency: мапа хост → диапазон latency
        Map<String, int[]> latencyProfile = Map.of(
            "10.0.0.1", new int[]{80, 120},
            "10.0.0.2", new int[]{150, 250},
            "10.0.0.3", new int[]{50, 70}
        );

        ExecutorService requestPool = Executors.newFixedThreadPool(32);
        AtomicLong requestCount = new AtomicLong();
        long startTime = System.currentTimeMillis();
        long endTime = startTime + 300_000; // 5 минут

        // Поток: нагрузка
        Runnable trafficGenerator = () -> {
            Random rand = new Random();
            while (System.currentTimeMillis() < endTime) {
                String host = lb.getHost();
                if (host == null) continue;
                int[] range = latencyProfile.getOrDefault(host, new int[]{100, 200});
                long latency = range[0] + rand.nextInt(range[1] - range[0] + 1);
                lb.recordResponseTime(host, latency);
                requestCount.incrementAndGet();

                try {
                    Thread.sleep(1); // Минимальная пауза между запросами
                } catch (InterruptedException ignored) {
                }
            }
        };

        // Поток: логирование RPS каждую секунду
        Thread rpsLogger = new Thread(() -> {
            long lastCount = 0;
            while (System.currentTimeMillis() < endTime) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException ignored) {
                }
                long current = requestCount.get();
                long rps = current - lastCount;
                lastCount = current;
                System.out.println("[RPS] " + rps + " req/s");
            }
        });

        // Поток: логирование latency каждые 10 секунд
        Thread latencyLogger = new Thread(() -> {
            while (System.currentTimeMillis() < endTime) {
                try {
                    Thread.sleep(10_000);
                } catch (InterruptedException ignored) {
                }
                System.out.println("---- Средние latency за последние 10 секунд ----");
                for (String host : lb.getAllHosts()) {
                    double avg = lb.getHostLatencyAverage(host);
                    System.out.printf("  %s : %.2f ms%n", host, avg);
                }
                System.out.println("------------------------------------------------");
            }
        });

        // Запускаем
        for (int i = 0; i < 16; i++) {
            requestPool.submit(trafficGenerator);
        }
        rpsLogger.start();
        latencyLogger.start();

        // Ждём завершения
        requestPool.shutdown();
        requestPool.awaitTermination(6, TimeUnit.MINUTES); // с запасом
        rpsLogger.join();
        latencyLogger.join();

        System.out.println("=== Тест завершён ===");
    }
}


import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.*;
import java.util.stream.Collectors;

public class LatencyBasedLoadBalancer {

    private static class LatencyEntry {
        final long timestampMillis;
        final long latencyMillis;

        LatencyEntry(long timestampMillis, long latencyMillis) {
            this.timestampMillis = timestampMillis;
            this.latencyMillis = latencyMillis;
        }
    }

    private static class HostStats {
        final String host;
        final Deque<LatencyEntry> latencyWindow = new ConcurrentLinkedDeque<>();
        final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

        HostStats(String host) {
            this.host = host;
        }

        void recordLatency(long latencyMillis, long nowMillis, long windowSizeMillis) {
            lock.writeLock().lock();
            try {
                latencyWindow.addLast(new LatencyEntry(nowMillis, latencyMillis));
                // Remove outdated entries
                while (!latencyWindow.isEmpty() && nowMillis - latencyWindow.peekFirst().timestampMillis > windowSizeMillis) {
                    latencyWindow.pollFirst();
                }
            } finally {
                lock.writeLock().unlock();
            }
        }

        double getAverageLatency(long nowMillis, long windowSizeMillis) {
            lock.readLock().lock();
            try {
                List<LatencyEntry> valid = latencyWindow.stream()
                        .filter(e -> nowMillis - e.timestampMillis <= windowSizeMillis)
                        .collect(Collectors.toList());
                if (valid.isEmpty()) return Double.MAX_VALUE;
                long total = valid.stream().mapToLong(e -> e.latencyMillis).sum();
                return total / (double) valid.size();
            } finally {
                lock.readLock().unlock();
            }
        }
    }

    private final ConcurrentHashMap<String, HostStats> hosts = new ConcurrentHashMap<>();
    private final long windowSizeMillis;
    private final Random random = new Random();

    public LatencyBasedLoadBalancer(long windowSizeSeconds) {
        this.windowSizeMillis = windowSizeSeconds * 1000;
    }

    public void addHost(String host) {
        hosts.putIfAbsent(host, new HostStats(host));
    }

    public void removeHost(String host) {
        hosts.remove(host);
    }

    public void recordResponseTime(String host, long latencyMillis) {
        HostStats stats = hosts.get(host);
        if (stats != null) {
            stats.recordLatency(latencyMillis, System.currentTimeMillis(), windowSizeMillis);
        }
    }

    public double getHostLatencyAverage(String host) {
        HostStats stats = hosts.get(host);
        if (stats == null) return -1;
        return stats.getAverageLatency(System.currentTimeMillis(), windowSizeMillis);
    }

    public String getHost() {
        long now = System.currentTimeMillis();
        List<HostStats> available = new ArrayList<>(hosts.values());
        if (available.isEmpty()) return null;

        // Получаем latency и создаём веса: чем меньше latency, тем выше вес
        Map<HostStats, Double> scores = new HashMap<>();
        double totalWeight = 0;

        for (HostStats h : available) {
            double latency = h.getAverageLatency(now, windowSizeMillis);
            double weight = latency == Double.MAX_VALUE ? 0.0 : 1.0 / (latency + 1); // +1 чтобы избежать деления на 0
            scores.put(h, weight);
            totalWeight += weight;
        }

        if (totalWeight == 0.0) {
            // Все latency неизвестны — выбираем случайного
            return available.get(random.nextInt(available.size())).host;
        }

        // Взвешенный случайный выбор
        double r = random.nextDouble() * totalWeight;
        double cumulative = 0.0;

        for (Map.Entry<HostStats, Double> e : scores.entrySet()) {
            cumulative += e.getValue();
            if (r <= cumulative) {
                return e.getKey().host;
            }
        }

        // fallback — возвращаем случайный
        return available.get(random.nextInt(available.size())).host;
    }

    // Метод для получения всех хостов (например, для метрик или дебага)
    public List<String> getAllHosts() {
        return new ArrayList<>(hosts.keySet());
    }
}
