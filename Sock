import java.net.StandardProtocolFamily;
import java.net.UnixDomainSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class UnixSocketServer {

    private static final String SOCKET_PATH = "/tmp/test-ipc.sock";
    private static final int WORKERS =
            Runtime.getRuntime().availableProcessors() * 2;

    public static void main(String[] args) throws Exception {

        Path socket = Path.of(SOCKET_PATH);
        Files.deleteIfExists(socket);

        ServerSocketChannel server =
                ServerSocketChannel.open(StandardProtocolFamily.UNIX);
        server.bind(UnixDomainSocketAddress.of(socket));

        ExecutorService pool = Executors.newFixedThreadPool(WORKERS);

        System.out.println("Helper started, workers=" + WORKERS);

        while (true) {
            SocketChannel client = server.accept();
            pool.submit(() -> handle(client));
        }
    }

    private static void handle(SocketChannel client) {
        try (client) {

            ByteBuffer lenBuf = ByteBuffer.allocate(2);
            if (client.read(lenBuf) != 2) return;
            lenBuf.flip();
            int len = lenBuf.getShort();

            ByteBuffer dataBuf = ByteBuffer.allocate(len);
            while (dataBuf.hasRemaining()) {
                client.read(dataBuf);
            }
            dataBuf.flip();

            String payload =
                    StandardCharsets.UTF_8.decode(dataBuf).toString();

            // имитация policy check
            boolean allowed = payload.startsWith("user");

            client.write(ByteBuffer.wrap(
                    new byte[]{(byte) (allowed ? 1 : 0)}
            ));

        } catch (Exception ignored) {
        }
    }
}

import java.net.StandardProtocolFamily;
import java.net.UnixDomainSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class UnixSocketClient {

    private static final String SOCKET_PATH = "/tmp/test-ipc.sock";

    public static void main(String[] args) throws Exception {

        int parallelism = 64;          // число потоков
        int totalRequests = 100_000;   // всего запросов

        ExecutorService pool =
                Executors.newFixedThreadPool(parallelism);

        CountDownLatch latch =
                new CountDownLatch(totalRequests);

        long start = System.nanoTime();

        for (int i = 0; i < totalRequests; i++) {
            final int id = i;
            pool.submit(() -> {
                try {
                    send("user" + (id % 10));
                } catch (Exception ignored) {
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await();

        long end = System.nanoTime();
        long ms = (end - start) / 1_000_000;

        System.out.println("Requests: " + totalRequests);
        System.out.println("Time ms: " + ms);

        pool.shutdown();
    }

    private static void send(String user) throws Exception {

        try (SocketChannel channel =
                     SocketChannel.open(StandardProtocolFamily.UNIX)) {

            channel.connect(UnixDomainSocketAddress.of(SOCKET_PATH));

            byte[] data = user.getBytes(StandardCharsets.UTF_8);

            ByteBuffer buf = ByteBuffer.allocate(2 + data.length);
            buf.putShort((short) data.length);
            buf.put(data);
            buf.flip();

            channel.write(buf);

            ByteBuffer resp = ByteBuffer.allocate(1);
            channel.read(resp);
        }
    }
}
