Вот реализация балансировщика на Java с несколькими стратегиями балансировки:

```java
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class LoadBalancer {
    
    private final Map<String, HostStats> hostsStats = new ConcurrentHashMap<>();
    private final ReadWriteLock hostsLock = new ReentrantReadWriteLock();
    private BalancingStrategy strategy = BalancingStrategy.WEIGHTED_RESPONSE_TIME;
    
    // Интерфейс для стратегий балансировки
    public enum BalancingStrategy {
        ROUND_ROBIN,
        LEAST_CONNECTIONS,
        WEIGHTED_RESPONSE_TIME,
        RANDOM
    }
    
    // Класс для хранения статистики хоста
    private static class HostStats {
        private final String host;
        private final Queue<ResponseTime> responseTimes = new ConcurrentLinkedQueue<>();
        private int activeConnections = 0;
        private int requestCount = 0;
        
        public HostStats(String host) {
            this.host = host;
        }
        
        public void addResponseTime(long responseTimeMs) {
            responseTimes.add(new ResponseTime(Instant.now(), responseTimeMs));
            cleanupOldStats();
        }
        
        public double getAverageResponseTime() {
            cleanupOldStats();
            if (responseTimes.isEmpty()) {
                return 0;
            }
            
            return responseTimes.stream()
                    .mapToLong(ResponseTime::getResponseTimeMs)
                    .average()
                    .orElse(0);
        }
        
        private void cleanupOldStats() {
            Instant fiveMinutesAgo = Instant.now().minus(Duration.ofMinutes(5));
            responseTimes.removeIf(rt -> rt.getTimestamp().isBefore(fiveMinutesAgo));
        }
        
        public void incrementConnections() {
            activeConnections++;
            requestCount++;
        }
        
        public void decrementConnections() {
            activeConnections--;
        }
        
        public int getActiveConnections() {
            return activeConnections;
        }
        
        public int getRequestCount() {
            return requestCount;
        }
    }
    
    private static class ResponseTime {
        private final Instant timestamp;
        private final long responseTimeMs;
        
        public ResponseTime(Instant timestamp, long responseTimeMs) {
            this.timestamp = timestamp;
            this.responseTimeMs = responseTimeMs;
        }
        
        public Instant getTimestamp() {
            return timestamp;
        }
        
        public long getResponseTimeMs() {
            return responseTimeMs;
        }
    }
    
    // Добавление нового хоста
    public void addHost(String host) {
        hostsLock.writeLock().lock();
        try {
            hostsStats.putIfAbsent(host, new HostStats(host));
        } finally {
            hostsLock.writeLock().unlock();
        }
    }
    
    // Удаление хоста
    public boolean removeHost(String host) {
        hostsLock.writeLock().lock();
        try {
            return hostsStats.remove(host) != null;
        } finally {
            hostsLock.writeLock().unlock();
        }
    }
    
    // Установка стратегии балансировки
    public void setStrategy(BalancingStrategy strategy) {
        this.strategy = strategy;
    }
    
    // Получение хоста для запроса
    public String getHost() {
        hostsLock.readLock().lock();
        try {
            if (hostsStats.isEmpty()) {
                throw new IllegalStateException("No hosts available");
            }
            
            String selectedHost;
            
            switch (strategy) {
                case ROUND_ROBIN:
                    selectedHost = roundRobinStrategy();
                    break;
                case LEAST_CONNECTIONS:
                    selectedHost = leastConnectionsStrategy();
                    break;
                case WEIGHTED_RESPONSE_TIME:
                    selectedHost = weightedResponseTimeStrategy();
                    break;
                case RANDOM:
                    selectedHost = randomStrategy();
                    break;
                default:
                    selectedHost = weightedResponseTimeStrategy();
            }
            
            hostsStats.get(selectedHost).incrementConnections();
            return selectedHost;
        } finally {
            hostsLock.readLock().unlock();
        }
    }
    
    // Регистрация времени ответа хоста
    public void registerResponseTime(String host, long responseTimeMs) {
        hostsLock.readLock().lock();
        try {
            HostStats stats = hostsStats.get(host);
            if (stats != null) {
                stats.addResponseTime(responseTimeMs);
                stats.decrementConnections();
            }
        } finally {
            hostsLock.readLock().unlock();
        }
    }
    
    // Стратегия Round Robin
    private String roundRobinStrategy() {
        List<String> hosts = new ArrayList<>(hostsStats.keySet());
        int minRequests = Integer.MAX_VALUE;
        String selectedHost = hosts.get(0);
        
        for (String host : hosts) {
            HostStats stats = hostsStats.get(host);
            if (stats.getRequestCount() < minRequests) {
                minRequests = stats.getRequestCount();
                selectedHost = host;
            }
        }
        
        return selectedHost;
    }
    
    // Стратегия наименьшего количества соединений
    private String leastConnectionsStrategy() {
        List<String> hosts = new ArrayList<>(hostsStats.keySet());
        int minConnections = Integer.MAX_VALUE;
        String selectedHost = hosts.get(0);
        
        for (String host : hosts) {
            HostStats stats = hostsStats.get(host);
            if (stats.getActiveConnections() < minConnections) {
                minConnections = stats.getActiveConnections();
                selectedHost = host;
            }
        }
        
        return selectedHost;
    }
    
    // Стратегия взвешенного времени ответа
    private String weightedResponseTimeStrategy() {
        List<String> hosts = new ArrayList<>(hostsStats.keySet());
        
        // Если у нас мало статистики, используем случайный выбор
        boolean hasStats = hosts.stream()
                .anyMatch(host -> hostsStats.get(host).getAverageResponseTime() > 0);
        
        if (!hasStats) {
            return randomStrategy();
        }
        
        // Вычисляем веса на основе обратного времени ответа
        Map<String, Double> weights = new HashMap<>();
        double totalWeight = 0;
        
        for (String host : hosts) {
            double avgResponseTime = hostsStats.get(host).getAverageResponseTime();
            // Избегаем деления на ноль
            double weight = avgResponseTime <= 0 ? 1.0 : 1.0 / avgResponseTime;
            weights.put(host, weight);
            totalWeight += weight;
        }
        
        // Выбираем хост на основе весов
        double random = Math.random() * totalWeight;
        double cumulativeWeight = 0;
        
        for (String host : hosts) {
            cumulativeWeight += weights.get(host);
            if (random <= cumulativeWeight) {
                return host;
            }
        }
        
        // Если что-то пошло не так, возвращаем случайный хост
        return hosts.get(0);
    }
    
    // Стратегия случайного выбора
    private String randomStrategy() {
        List<String> hosts = new ArrayList<>(hostsStats.keySet());
        int randomIndex = (int) (Math.random() * hosts.size());
        return hosts.get(randomIndex);
    }
    
    // Получение статистики по хостам
    public Map<String, Map<String, Object>> getHostsStatistics() {
        hostsLock.readLock().lock();
        try {
            Map<String, Map<String, Object>> result = new HashMap<>();
            
            for (Map.Entry<String, HostStats> entry : hostsStats.entrySet()) {
                HostStats stats = entry.getValue();
                Map<String, Object> hostStats = new HashMap<>();
                
                hostStats.put("activeConnections", stats.getActiveConnections());
                hostStats.put("requestCount", stats.getRequestCount());
                hostStats.put("averageResponseTime", stats.getAverageResponseTime());
                
                result.put(entry.getKey(), hostStats);
            }
            
            return result;
        } finally {
            hostsLock.readLock().unlock();
        }
    }
}
```

Хотите, чтобы я объяснил или разобрал этот код?

Обновляю реализацию с учетом высокой нагрузки и временного окна в 5 минут:

```java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class LoadBalancer {
    private static final int WINDOW_SIZE_SECONDS = 300; // 5 минут
    private static final int SLOTS_COUNT = 300; // По одному слоту на секунду
    private static final int CLEANUP_THRESHOLD = 1000; // Частота очистки старых данных
    
    private final List<String> hosts;
    private final ConcurrentHashMap<String, HostStats> hostStats;
    private final AtomicInteger requestCounter;
    
    private static class ResponseTime {
        final long timestamp;
        final long responseTime;
        
        ResponseTime(long responseTime) {
            this.timestamp = System.currentTimeMillis();
            this.responseTime = responseTime;
        }
        
        boolean isExpired() {
            return System.currentTimeMillis() - timestamp > WINDOW_SIZE_SECONDS * 1000L;
        }
    }
    
    private static class HostStats {
        private final Queue<ResponseTime>[] timeSlots;
        private final ReadWriteLock lock;
        private volatile double currentAvgResponseTime;
        
        @SuppressWarnings("unchecked")
        public HostStats() {
            this.timeSlots = new Queue[SLOTS_COUNT];
            for (int i = 0; i < SLOTS_COUNT; i++) {
                timeSlots[i] = new ArrayDeque<>();
            }
            this.lock = new ReentrantReadWriteLock();
            this.currentAvgResponseTime = 0;
        }
        
        public void addResponse(long responseTime) {
            int slot = (int) ((System.currentTimeMillis() / 1000) % SLOTS_COUNT);
            ResponseTime rt = new ResponseTime(responseTime);
            
            lock.writeLock().lock();
            try {
                timeSlots[slot].offer(rt);
                updateAvgResponseTime();
            } finally {
                lock.writeLock().unlock();
            }
        }
        
        private void updateAvgResponseTime() {
            long total = 0;
            int count = 0;
            long currentTime = System.currentTimeMillis();
            
            for (Queue<ResponseTime> slot : timeSlots) {
                for (ResponseTime rt : slot) {
                    if (currentTime - rt.timestamp <= WINDOW_SIZE_SECONDS * 1000L) {
                        total += rt.responseTime;
                        count++;
                    }
                }
            }
            
            currentAvgResponseTime = count > 0 ? (double) total / count : 0;
        }
        
        public double getAvgResponseTime() {
            return currentAvgResponseTime;
        }
        
        public void cleanup() {
            lock.writeLock().lock();
            try {
                for (Queue<ResponseTime> slot : timeSlots) {
                    while (!slot.isEmpty() && slot.peek().isExpired()) {
                        slot.poll();
                    }
                }
                updateAvgResponseTime();
            } finally {
                lock.writeLock().unlock();
            }
        }
    }
    
    public LoadBalancer(List<String> hosts) {
        this.hosts = new ArrayList<>(hosts);
        this.hostStats = new ConcurrentHashMap<>();
        this.requestCounter = new AtomicInteger(0);
        
        for (String host : hosts) {
            hostStats.put(host, new HostStats());
        }
    }
    
    public String getNextHost() {
        // Периодическая очистка старых данных
        if (requestCounter.incrementAndGet() % CLEANUP_THRESHOLD == 0) {
            cleanupOldData();
        }
        
        String selectedHost = null;
        double minScore = Double.MAX_VALUE;
        
        for (String host : hosts) {
            HostStats stats = hostStats.get(host);
            double avgResponseTime = stats.getAvgResponseTime();
            
            // Если хост еще не использовался или имеет лучшее время ответа
            if (avgResponseTime == 0) {
                return host;
            }
            
            if (avgResponseTime < minScore) {
                minScore = avgResponseTime;
                selectedHost = host;
            }
        }
        
        return selectedHost;
    }
    
    public void reportResponseTime(String host, long responseTimeMs) {
        HostStats stats = hostStats.get(host);
        if (stats != null) {
            stats.addResponse(responseTimeMs);
        }
    }
    
    private void cleanupOldData() {
        for (HostStats stats : hostStats.values()) {
            stats.cleanup();
        }
    }
    
    public Map<String, Double> getHostsStats() {
        Map<String, Double> stats = new HashMap<>();
        for (Map.Entry<String, HostStats> entry : hostStats.entrySet()) {
            stats.put(entry.getKey(), entry.getValue().getAvgResponseTime());
        }
        return stats;
    }
}
```

Основные улучшения:

1. Использование временных слотов (по секунде) для более эффективного хранения и очистки данных

2. Оптимизация работы с памятью:
   - Циклический буфер для временных слотов
   - Периодическая очистка устаревших данных
   - Эффективное обновление средних значений

3. Улучшенная конкурентность:
   - Использование ReadWriteLock для уменьшения блокировок при чтении
   - ConcurrentHashMap для потокобезопасного доступа к статистике хостов
   - Атомарный счетчик для отслеживания запросов

4. Оптимизация производительности:
   - Кэширование среднего времени ответа
   - Очистка старых данных происходит не при каждом запросе
   - Минимизация блокировок

Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        List<String> hosts = Arrays.asList(
            "server1.example.com",
            "server2.example.com",
            "server3.example.com"
        );
        
        LoadBalancer balancer = new LoadBalancer(hosts);
        
        // Симуляция высокой нагрузки
        ExecutorService executor = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 100000; i++) {
            executor.submit(() -> {
                String host = balancer.getNextHost();
                // Имитация случайного времени ответа
                long responseTime = (long) (Math.random() * 100);
                balancer.reportResponseTime(host, responseTime);
            });
        }
        
        executor.shutdown();
    }
}
```

Эта реализация должна эффективно справляться с нагрузкой в 30000 запросов в секунду, поддерживая актуальную статистику за последние 5 минут.


java import java.util.*; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class LoadBalancer { private static final int WINDOW_SIZE_SECONDS = 300; // 5 минут private static final int SLOTS_COUNT = 300; // По одному слоту на секунду private static final int CLEANUP_THRESHOLD = 1000; // Частота очистки старых данных private final List<String> hosts; private final ConcurrentHashMap<String, HostStats> hostStats; private final AtomicInteger requestCounter; private static class ResponseTime { final long timestamp; final long responseTime; ResponseTime(long responseTime) { this.timestamp = System.currentTimeMillis(); this.responseTime = responseTime; } boolean isExpired() { return System.currentTimeMillis() - timestamp > WINDOW_SIZE_SECONDS * 1000L; } } private static class HostStats { private final Queue<ResponseTime>[] timeSlots; private final ReadWriteLock lock; private volatile double currentAvgResponseTime; @SuppressWarnings("unchecked") public HostStats() { this.timeSlots = new Queue[SLOTS_COUNT]; for (int i = 0; i < SLOTS_COUNT; i++) { timeSlots[i] = new ArrayDeque<>(); } this.lock = new ReentrantReadWriteLock(); this.currentAvgResponseTime = 0; } public void addResponse(long responseTime) { int slot = (int) ((System.currentTimeMillis() / 1000) % SLOTS_COUNT); ResponseTime rt = new ResponseTime(responseTime); lock.writeLock().lock(); try { timeSlots[slot].offer(rt); updateAvgResponseTime(); } finally { lock.writeLock().unlock(); } } private void updateAvgResponseTime() { long total = 0; int count = 0; long currentTime = System.currentTimeMillis(); for (Queue<ResponseTime> slot : timeSlots) { for (ResponseTime rt : slot) { if (currentTime - rt.timestamp <= WINDOW_SIZE_SECONDS * 1000L) { total += rt.responseTime; count++; } } } currentAvgResponseTime = count > 0 ? (double) total / count : 0; } public double getAvgResponseTime() { return currentAvgResponseTime; } public void cleanup() { lock.writeLock().lock(); try { for (Queue<ResponseTime> slot : timeSlots) { while (!slot.isEmpty() && slot.peek().isExpired()) { slot.poll(); } } updateAvgResponseTime(); } finally { lock.writeLock().unlock(); } } } public LoadBalancer(List<String> hosts) { this.hosts = new ArrayList<>(hosts); this.hostStats = new ConcurrentHashMap<>(); this.requestCounter = new AtomicInteger(0); for (String host : hosts) { hostStats.put(host, new HostStats()); } } public String getNextHost() { // Периодическая очистка старых данных if (requestCounter.incrementAndGet() % CLEANUP_THRESHOLD == 0) { cleanupOldData(); } String selectedHost = null; double minScore = Double.MAX_VALUE; for (String host : hosts) { HostStats stats = hostStats.get(host); double avgResponseTime = stats.getAvgResponseTime(); // Если хост еще не использовался или имеет лучшее время ответа if (avgResponseTime == 0) { return host; } if (avgResponseTime < minScore) { minScore = avgResponseTime; selectedHost = host; } } return selectedHost; } public void reportResponseTime(String host, long responseTimeMs) { HostStats stats = hostStats.get(host); if (stats != null) { stats.addResponse(responseTimeMs); } } private void cleanupOldData() { for (HostStats stats : hostStats.values()) { stats.cleanup(); } } public Map<String, Double> getHostsStats() { Map<String, Double> stats = new HashMap<>(); for (Map.Entry<String, HostStats> entry : hostStats.entrySet()) { stats.put(entry.getKey(), entry.getValue().getAvgResponseTime()); } return stats; } } 


java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class LoadBalancer {
    private final List<String> hosts;
    private final Map<String, HostStats> hostStats;
    
    private static class HostStats {
        private double avgResponseTime;
        private int requestCount;
        
        public HostStats() {
            this.avgResponseTime = 0;
            this.requestCount = 0;
        }
        
        public void updateStats(long responseTime) {
            avgResponseTime = (avgResponseTime * requestCount + responseTime) / (requestCount + 1);
            requestCount++;
        }
    }
    
    public LoadBalancer(List<String> hosts) {
        this.hosts = new ArrayList<>(hosts);
        this.hostStats = new ConcurrentHashMap<>();
        
        for (String host : hosts) {
            hostStats.put(host, new HostStats());
        }
    }
    
    public String getNextHost() {
        String selectedHost = null;
        double minScore = Double.MAX_VALUE;
        
        for (String host : hosts) {
            HostStats stats = hostStats.get(host);
            // Вычисляем score на основе среднего времени ответа и количества запросов
            double score = stats.avgResponseTime * (stats.requestCount + 1);
            
            if (score < minScore) {
                minScore = score;
                selectedHost = host;
            }
        }
        
        return selectedHost;
    }
    
    public void reportResponseTime(String host, long responseTimeMs) {
        HostStats stats = hostStats.get(host);
        if (stats != null) {
            stats.updateStats(responseTimeMs);
        }
    }
    
    public Map<String, Double> getHostsStats() {
        Map<String, Double> stats = new HashMap<>();
        for (Map.Entry<String, HostStats> entry : hostStats.entrySet()) {
            stats.put(entry.getKey(), entry.getValue().avgResponseTime);
        }
        return stats;
    }
}
```

Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        // Инициализация балансировщика
        List<String> hosts = Arrays.asList(
            "server1.example.com",
            "server2.example.com",
            "server3.example.com"
        );
        
        LoadBalancer balancer = new LoadBalancer(hosts);
        
        // Получение хоста и отправка статистики
        String host = balancer.getNextHost();
        System.out.println("Selected host: " + host);
        
        // Имитация запроса и отправка времени ответа
        balancer.reportResponseTime(host, 150); // 150ms response time
        
        // Получение статистики
        Map<String, Double> stats = balancer.getHostsStats();
        System.out.println("Current stats: " + stats);
    }
}
