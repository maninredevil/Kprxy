java import java.util.*; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class LoadBalancer { private static final int WINDOW_SIZE_SECONDS = 300; // 5 минут private static final int SLOTS_COUNT = 300; // По одному слоту на секунду private static final int CLEANUP_THRESHOLD = 1000; // Частота очистки старых данных private final List<String> hosts; private final ConcurrentHashMap<String, HostStats> hostStats; private final AtomicInteger requestCounter; private static class ResponseTime { final long timestamp; final long responseTime; ResponseTime(long responseTime) { this.timestamp = System.currentTimeMillis(); this.responseTime = responseTime; } boolean isExpired() { return System.currentTimeMillis() - timestamp > WINDOW_SIZE_SECONDS * 1000L; } } private static class HostStats { private final Queue<ResponseTime>[] timeSlots; private final ReadWriteLock lock; private volatile double currentAvgResponseTime; @SuppressWarnings("unchecked") public HostStats() { this.timeSlots = new Queue[SLOTS_COUNT]; for (int i = 0; i < SLOTS_COUNT; i++) { timeSlots[i] = new ArrayDeque<>(); } this.lock = new ReentrantReadWriteLock(); this.currentAvgResponseTime = 0; } public void addResponse(long responseTime) { int slot = (int) ((System.currentTimeMillis() / 1000) % SLOTS_COUNT); ResponseTime rt = new ResponseTime(responseTime); lock.writeLock().lock(); try { timeSlots[slot].offer(rt); updateAvgResponseTime(); } finally { lock.writeLock().unlock(); } } private void updateAvgResponseTime() { long total = 0; int count = 0; long currentTime = System.currentTimeMillis(); for (Queue<ResponseTime> slot : timeSlots) { for (ResponseTime rt : slot) { if (currentTime - rt.timestamp <= WINDOW_SIZE_SECONDS * 1000L) { total += rt.responseTime; count++; } } } currentAvgResponseTime = count > 0 ? (double) total / count : 0; } public double getAvgResponseTime() { return currentAvgResponseTime; } public void cleanup() { lock.writeLock().lock(); try { for (Queue<ResponseTime> slot : timeSlots) { while (!slot.isEmpty() && slot.peek().isExpired()) { slot.poll(); } } updateAvgResponseTime(); } finally { lock.writeLock().unlock(); } } } public LoadBalancer(List<String> hosts) { this.hosts = new ArrayList<>(hosts); this.hostStats = new ConcurrentHashMap<>(); this.requestCounter = new AtomicInteger(0); for (String host : hosts) { hostStats.put(host, new HostStats()); } } public String getNextHost() { // Периодическая очистка старых данных if (requestCounter.incrementAndGet() % CLEANUP_THRESHOLD == 0) { cleanupOldData(); } String selectedHost = null; double minScore = Double.MAX_VALUE; for (String host : hosts) { HostStats stats = hostStats.get(host); double avgResponseTime = stats.getAvgResponseTime(); // Если хост еще не использовался или имеет лучшее время ответа if (avgResponseTime == 0) { return host; } if (avgResponseTime < minScore) { minScore = avgResponseTime; selectedHost = host; } } return selectedHost; } public void reportResponseTime(String host, long responseTimeMs) { HostStats stats = hostStats.get(host); if (stats != null) { stats.addResponse(responseTimeMs); } } private void cleanupOldData() { for (HostStats stats : hostStats.values()) { stats.cleanup(); } } public Map<String, Double> getHostsStats() { Map<String, Double> stats = new HashMap<>(); for (Map.Entry<String, HostStats> entry : hostStats.entrySet()) { stats.put(entry.getKey(), entry.getValue().getAvgResponseTime()); } return stats; } } 


java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class LoadBalancer {
    private final List<String> hosts;
    private final Map<String, HostStats> hostStats;
    
    private static class HostStats {
        private double avgResponseTime;
        private int requestCount;
        
        public HostStats() {
            this.avgResponseTime = 0;
            this.requestCount = 0;
        }
        
        public void updateStats(long responseTime) {
            avgResponseTime = (avgResponseTime * requestCount + responseTime) / (requestCount + 1);
            requestCount++;
        }
    }
    
    public LoadBalancer(List<String> hosts) {
        this.hosts = new ArrayList<>(hosts);
        this.hostStats = new ConcurrentHashMap<>();
        
        for (String host : hosts) {
            hostStats.put(host, new HostStats());
        }
    }
    
    public String getNextHost() {
        String selectedHost = null;
        double minScore = Double.MAX_VALUE;
        
        for (String host : hosts) {
            HostStats stats = hostStats.get(host);
            // Вычисляем score на основе среднего времени ответа и количества запросов
            double score = stats.avgResponseTime * (stats.requestCount + 1);
            
            if (score < minScore) {
                minScore = score;
                selectedHost = host;
            }
        }
        
        return selectedHost;
    }
    
    public void reportResponseTime(String host, long responseTimeMs) {
        HostStats stats = hostStats.get(host);
        if (stats != null) {
            stats.updateStats(responseTimeMs);
        }
    }
    
    public Map<String, Double> getHostsStats() {
        Map<String, Double> stats = new HashMap<>();
        for (Map.Entry<String, HostStats> entry : hostStats.entrySet()) {
            stats.put(entry.getKey(), entry.getValue().avgResponseTime);
        }
        return stats;
    }
}
```

Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        // Инициализация балансировщика
        List<String> hosts = Arrays.asList(
            "server1.example.com",
            "server2.example.com",
            "server3.example.com"
        );
        
        LoadBalancer balancer = new LoadBalancer(hosts);
        
        // Получение хоста и отправка статистики
        String host = balancer.getNextHost();
        System.out.println("Selected host: " + host);
        
        // Имитация запроса и отправка времени ответа
        balancer.reportResponseTime(host, 150); // 150ms response time
        
        // Получение статистики
        Map<String, Double> stats = balancer.getHostsStats();
        System.out.println("Current stats: " + stats);
    }
}
