Вот оптимизированная версия балансировщика для высоконагруженных систем с 30+ тыс. запросов в секунду:

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReferenceArray;

public class HighPerformanceLoadBalancer {
    
    // Константы
    private static final int RESPONSE_TIME_WINDOW_SIZE = 1000; // Размер окна для хранения времен ответа
    private static final long STATS_WINDOW_MS = 300_000; // 5 минут в миллисекундах
    
    // Стратегии балансировки
    public enum Strategy {
        ROUND_ROBIN,
        LEAST_CONNECTIONS,
        WEIGHTED_RESPONSE_TIME,
        RANDOM
    }
    
    private volatile Strategy strategy = Strategy.WEIGHTED_RESPONSE_TIME;
    private final Map<String, HostData> hostsMap = new ConcurrentHashMap<>();
    private volatile String[] hostsList = new String[0]; // Атомарно обновляемый список хостов
    private final AtomicInteger roundRobinCounter = new AtomicInteger(0);
    
    // Класс для хранения данных о хосте с оптимизацией для высокой нагрузки
    private static class HostData {
        private final String host;
        private final AtomicReferenceArray<ResponseTime> responseTimes;
        private final AtomicInteger responseTimeIndex = new AtomicInteger(0);
        private final AtomicInteger activeConnections = new AtomicInteger(0);
        private final AtomicInteger requestCount = new AtomicInteger(0);
        
        // Кэшированное значение среднего времени ответа
        private volatile double cachedAvgResponseTime = 0;
        private volatile long lastAvgCalculationTime = 0;
        private static final long AVG_CACHE_DURATION_MS = 1000; // Обновлять среднее не чаще раза в секунду
        
        public HostData(String host) {
            this.host = host;
            this.responseTimes = new AtomicReferenceArray<>(RESPONSE_TIME_WINDOW_SIZE);
        }
        
        public void recordResponseTime(long responseTimeMs) {
            int index = responseTimeIndex.getAndIncrement() % RESPONSE_TIME_WINDOW_SIZE;
            responseTimes.set(index, new ResponseTime(System.currentTimeMillis(), responseTimeMs));
            activeConnections.decrementAndGet();
        }
        
        public void incrementConnections() {
            activeConnections.incrementAndGet();
            requestCount.incrementAndGet();
        }
        
        public int getActiveConnections() {
            return activeConnections.get();
        }
        
        public double getAverageResponseTime() {
            long now = System.currentTimeMillis();
            
            // Используем кэшированное значение, если оно достаточно свежее
            if (now - lastAvgCalculationTime < AVG_CACHE_DURATION_MS) {
                return cachedAvgResponseTime;
            }
            
            // Иначе пересчитываем среднее время ответа
            long cutoffTime = now - STATS_WINDOW_MS;
            long sum = 0;
            int count = 0;
            
            for (int i = 0; i < RESPONSE_TIME_WINDOW_SIZE; i++) {
                ResponseTime rt = responseTimes.get(i);
                if (rt != null && rt.timestamp > cutoffTime) {
                    sum += rt.responseTimeMs;
                    count++;
                }
            }
            
            double avg = count > 0 ? (double) sum / count : 0;
            cachedAvgResponseTime = avg;
            lastAvgCalculationTime = now;
            
            return avg;
        }
    }
    
    private static class ResponseTime {
        final long timestamp;
        final long responseTimeMs;
        
        ResponseTime(long timestamp, long responseTimeMs) {
            this.timestamp = timestamp;
            this.responseTimeMs = responseTimeMs;
        }
    }
    
    // Добавление хоста
    public void addHost(String host) {
        if (!hostsMap.containsKey(host)) {
            hostsMap.put(host, new HostData(host));
            updateHostsList();
        }
    }
    
    // Удаление хоста
    public boolean removeHost(String host) {
        if (hostsMap.remove(host) != null) {
            updateHostsList();
            return true;
        }
        return false;
    }
    
    // Атомарное обновление списка хостов
    private void updateHostsList() {
        hostsList = hostsMap.keySet().toArray(new String[0]);
    }
    
    // Установка стратегии балансировки
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
    
    // Получение хоста для запроса
    public String getHost() {
        String[] currentHosts = hostsList;
        if (currentHosts.length == 0) {
            throw new IllegalStateException("No hosts available");
        }
        
        if (currentHosts.length == 1) {
            String host = currentHosts[0];
            hostsMap.get(host).incrementConnections();
            return host;
        }
        
        String selectedHost;
        
        switch (strategy) {
            case ROUND_ROBIN:
                selectedHost = roundRobinStrategy(currentHosts);
                break;
            case LEAST_CONNECTIONS:
                selectedHost = leastConnectionsStrategy(currentHosts);
                break;
            case WEIGHTED_RESPONSE_TIME:
                selectedHost = weightedResponseTimeStrategy(currentHosts);
                break;
            case RANDOM:
                selectedHost = randomStrategy(currentHosts);
                break;
            default:
                selectedHost = weightedResponseTimeStrategy(currentHosts);
        }
        
        hostsMap.get(selectedHost).incrementConnections();
        return selectedHost;
    }
    
    // Регистрация времени ответа хоста
    public void registerResponseTime(String host, long responseTimeMs) {
        HostData hostData = hostsMap.get(host);
        if (hostData != null) {
            hostData.recordResponseTime(responseTimeMs);
        }
    }
    
    // Стратегия Round Robin с оптимизацией
    private String roundRobinStrategy(String[] hosts) {
        int index = roundRobinCounter.getAndIncrement() & Integer.MAX_VALUE;
        return hosts[index % hosts.length];
    }
    
    // Стратегия наименьшего количества соединений
    private String leastConnectionsStrategy(String[] hosts) {
        String selectedHost = hosts[0];
        int minConnections = hostsMap.get(selectedHost).getActiveConnections();
        
        // Проверяем только несколько случайных хостов для повышения производительности
        int samplesToCheck = Math.min(hosts.length, 3);
        
        for (int i = 0; i < samplesToCheck; i++) {
            int randomIndex = ThreadLocalRandom.current().nextInt(hosts.length);
            String host = hosts[randomIndex];
            int connections = hostsMap.get(host).getActiveConnections();
            
            if (connections < minConnections) {
                minConnections = connections;
                selectedHost = host;
            }
        }
        
        return selectedHost;
    }
    
    // Стратегия взвешенного времени ответа с оптимизацией
    private String weightedResponseTimeStrategy(String[] hosts) {
        // Используем алгоритм "Power of Two Choices" для эффективности
        int idx1 = ThreadLocalRandom.current().nextInt(hosts.length);
        int idx2 = ThreadLocalRandom.current().nextInt(hosts.length);
        
        String host1 = hosts[idx1];
        String host2 = hosts[idx2];
        
        double rt1 = hostsMap.get(host1).getAverageResponseTime();
        double rt2 = hostsMap.get(host2).getAverageResponseTime();
        
        // Если нет статистики, используем соединения
        if (rt1 <= 0 && rt2 <= 0) {
            int conn1 = hostsMap.get(host1).getActiveConnections();
            int conn2 = hostsMap.get(host2).getActiveConnections();
            return conn1 <= conn2 ? host1 : host2;
        }
        
        // Если у одного хоста нет статистики
        if (rt1 <= 0) return host2;
        if (rt2 <= 0) return host1;
        
        // Выбираем хост с лучшим временем ответа, но с небольшой вероятностью
        // выбираем другой хост для обеспечения плавной балансировки
        if (rt1 < rt2) {
            return ThreadLocalRandom.current().nextDouble() < 0.8 ? host1 : host2;
        } else {
            return ThreadLocalRandom.current().nextDouble() < 0.8 ? host2 : host1;
        }
    }
    
    // Стратегия случайного выбора
    private String randomStrategy(String[] hosts) {
        int randomIndex = ThreadLocalRandom.current().nextInt(hosts.length);
        return hosts[randomIndex];
    }
    
    // Получение базовой статистики (облегченная версия)
    public Map<String, HostStats> getBasicStats() {
        Map<String, HostStats> stats = new ConcurrentHashMap<>();
        
        for (Map.Entry<String, HostData> entry : hostsMap.entrySet()) {
            HostData data = entry.getValue();
            stats.put(entry.getKey(), new HostStats(
                data.getActiveConnections(),
                data.getAverageResponseTime()
            ));
        }
        
        return stats;
    }
    
    // Легковесный класс для возврата статистики
    public static class HostStats {
        public final int activeConnections;
        public final double avgResponseTime;
        
        public HostStats(int activeConnections, double avgResponseTime) {
            this.activeConnections = activeConnections;
            this.avgResponseTime = avgResponseTime;
        }
    }
}
```

Ключевые оптимизации для высокой производительности:

1. **Минимизация блокировок** - использование неблокирующих структур данных (ConcurrentHashMap, AtomicInteger)
2. **Эффективное хранение времен ответа** - использование циклического буфера фиксированного размера
3. **Кэширование среднего времени ответа** - пересчет не чаще раза в секунду
4. **Оптимизация стратегий балансировки**:
   - Для Round Robin используется простой счетчик с побитовой операцией
   - Для Least Connections проверяется только выборка хостов
   - Для Weighted Response Time используется алгоритм "Power of Two Choices"
5. **Эффективное обновление списка хостов** - атомарное обновление массива
6. **Использование ThreadLocalRandom** вместо Math.random() для лучшей производительности в многопоточной среде
7. **Оптимизация для случая одного хоста** - быстрый путь возврата

Эта реализация должна обеспечить высокую пропускную способность и низкую задержку при обработке 30+ тысяч запросов в секунду.




Вот реализация балансировщика на Java с несколькими стратегиями балансировки:

```java
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class LoadBalancer {
    
    private final Map<String, HostStats> hostsStats = new ConcurrentHashMap<>();
    private final ReadWriteLock hostsLock = new ReentrantReadWriteLock();
    private BalancingStrategy strategy = BalancingStrategy.WEIGHTED_RESPONSE_TIME;
    
    // Интерфейс для стратегий балансировки
    public enum BalancingStrategy {
        ROUND_ROBIN,
        LEAST_CONNECTIONS,
        WEIGHTED_RESPONSE_TIME,
        RANDOM
    }
    
    // Класс для хранения статистики хоста
    private static class HostStats {
        private final String host;
        private final Queue<ResponseTime> responseTimes = new ConcurrentLinkedQueue<>();
        private int activeConnections = 0;
        private int requestCount = 0;
        
        public HostStats(String host) {
            this.host = host;
        }
        
        public void addResponseTime(long responseTimeMs) {
            responseTimes.add(new ResponseTime(Instant.now(), responseTimeMs));
            cleanupOldStats();
        }
        
        public double getAverageResponseTime() {
            cleanupOldStats();
            if (responseTimes.isEmpty()) {
                return 0;
            }
            
            return responseTimes.stream()
                    .mapToLong(ResponseTime::getResponseTimeMs)
                    .average()
                    .orElse(0);
        }
        
        private void cleanupOldStats() {
            Instant fiveMinutesAgo = Instant.now().minus(Duration.ofMinutes(5));
            responseTimes.removeIf(rt -> rt.getTimestamp().isBefore(fiveMinutesAgo));
        }
        
        public void incrementConnections() {
            activeConnections++;
            requestCount++;
        }
        
        public void decrementConnections() {
            activeConnections--;
        }
        
        public int getActiveConnections() {
            return activeConnections;
        }
        
        public int getRequestCount() {
            return requestCount;
        }
    }
    
    private static class ResponseTime {
        private final Instant timestamp;
        private final long responseTimeMs;
        
        public ResponseTime(Instant timestamp, long responseTimeMs) {
            this.timestamp = timestamp;
            this.responseTimeMs = responseTimeMs;
        }
        
        public Instant getTimestamp() {
            return timestamp;
        }
        
        public long getResponseTimeMs() {
            return responseTimeMs;
        }
    }
    
    // Добавление нового хоста
    public void addHost(String host) {
        hostsLock.writeLock().lock();
        try {
            hostsStats.putIfAbsent(host, new HostStats(host));
        } finally {
            hostsLock.writeLock().unlock();
        }
    }
    
    // Удаление хоста
    public boolean removeHost(String host) {
        hostsLock.writeLock().lock();
        try {
            return hostsStats.remove(host) != null;
        } finally {
            hostsLock.writeLock().unlock();
        }
    }
    
    // Установка стратегии балансировки
    public void setStrategy(BalancingStrategy strategy) {
        this.strategy = strategy;
    }
    
    // Получение хоста для запроса
    public String getHost() {
        hostsLock.readLock().lock();
        try {
            if (hostsStats.isEmpty()) {
                throw new IllegalStateException("No hosts available");
            }
            
            String selectedHost;
            
            switch (strategy) {
                case ROUND_ROBIN:
                    selectedHost = roundRobinStrategy();
                    break;
                case LEAST_CONNECTIONS:
                    selectedHost = leastConnectionsStrategy();
                    break;
                case WEIGHTED_RESPONSE_TIME:
                    selectedHost = weightedResponseTimeStrategy();
                    break;
                case RANDOM:
                    selectedHost = randomStrategy();
                    break;
                default:
                    selectedHost = weightedResponseTimeStrategy();
            }
            
            hostsStats.get(selectedHost).incrementConnections();
            return selectedHost;
        } finally {
            hostsLock.readLock().unlock();
        }
    }
    
    // Регистрация времени ответа хоста
    public void registerResponseTime(String host, long responseTimeMs) {
        hostsLock.readLock().lock();
        try {
            HostStats stats = hostsStats.get(host);
            if (stats != null) {
                stats.addResponseTime(responseTimeMs);
                stats.decrementConnections();
            }
        } finally {
            hostsLock.readLock().unlock();
        }
    }
    
    // Стратегия Round Robin
    private String roundRobinStrategy() {
        List<String> hosts = new ArrayList<>(hostsStats.keySet());
        int minRequests = Integer.MAX_VALUE;
        String selectedHost = hosts.get(0);
        
        for (String host : hosts) {
            HostStats stats = hostsStats.get(host);
            if (stats.getRequestCount() < minRequests) {
                minRequests = stats.getRequestCount();
                selectedHost = host;
            }
        }
        
        return selectedHost;
    }
    
    // Стратегия наименьшего количества соединений
    private String leastConnectionsStrategy() {
        List<String> hosts = new ArrayList<>(hostsStats.keySet());
        int minConnections = Integer.MAX_VALUE;
        String selectedHost = hosts.get(0);
        
        for (String host : hosts) {
            HostStats stats = hostsStats.get(host);
            if (stats.getActiveConnections() < minConnections) {
                minConnections = stats.getActiveConnections();
                selectedHost = host;
            }
        }
        
        return selectedHost;
    }
    
    // Стратегия взвешенного времени ответа
    private String weightedResponseTimeStrategy() {
        List<String> hosts = new ArrayList<>(hostsStats.keySet());
        
        // Если у нас мало статистики, используем случайный выбор
        boolean hasStats = hosts.stream()
                .anyMatch(host -> hostsStats.get(host).getAverageResponseTime() > 0);
        
        if (!hasStats) {
            return randomStrategy();
        }
        
        // Вычисляем веса на основе обратного времени ответа
        Map<String, Double> weights = new HashMap<>();
        double totalWeight = 0;
        
        for (String host : hosts) {
            double avgResponseTime = hostsStats.get(host).getAverageResponseTime();
            // Избегаем деления на ноль
            double weight = avgResponseTime <= 0 ? 1.0 : 1.0 / avgResponseTime;
            weights.put(host, weight);
            totalWeight += weight;
        }
        
        // Выбираем хост на основе весов
        double random = Math.random() * totalWeight;
        double cumulativeWeight = 0;
        
        for (String host : hosts) {
            cumulativeWeight += weights.get(host);
            if (random <= cumulativeWeight) {
                return host;
            }
        }
        
        // Если что-то пошло не так, возвращаем случайный хост
        return hosts.get(0);
    }
    
    // Стратегия случайного выбора
    private String randomStrategy() {
        List<String> hosts = new ArrayList<>(hostsStats.keySet());
        int randomIndex = (int) (Math.random() * hosts.size());
        return hosts.get(randomIndex);
    }
    
    // Получение статистики по хостам
    public Map<String, Map<String, Object>> getHostsStatistics() {
        hostsLock.readLock().lock();
        try {
            Map<String, Map<String, Object>> result = new HashMap<>();
            
            for (Map.Entry<String, HostStats> entry : hostsStats.entrySet()) {
                HostStats stats = entry.getValue();
                Map<String, Object> hostStats = new HashMap<>();
                
                hostStats.put("activeConnections", stats.getActiveConnections());
                hostStats.put("requestCount", stats.getRequestCount());
                hostStats.put("averageResponseTime", stats.getAverageResponseTime());
                
                result.put(entry.getKey(), hostStats);
            }
            
            return result;
        } finally {
            hostsLock.readLock().unlock();
        }
    }
}
```

Хотите, чтобы я объяснил или разобрал этот код?

Обновляю реализацию с учетом высокой нагрузки и временного окна в 5 минут:

```java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class LoadBalancer {
    private static final int WINDOW_SIZE_SECONDS = 300; // 5 минут
    private static final int SLOTS_COUNT = 300; // По одному слоту на секунду
    private static final int CLEANUP_THRESHOLD = 1000; // Частота очистки старых данных
    
    private final List<String> hosts;
    private final ConcurrentHashMap<String, HostStats> hostStats;
    private final AtomicInteger requestCounter;
    
    private static class ResponseTime {
        final long timestamp;
        final long responseTime;
        
        ResponseTime(long responseTime) {
            this.timestamp = System.currentTimeMillis();
            this.responseTime = responseTime;
        }
        
        boolean isExpired() {
            return System.currentTimeMillis() - timestamp > WINDOW_SIZE_SECONDS * 1000L;
        }
    }
    
    private static class HostStats {
        private final Queue<ResponseTime>[] timeSlots;
        private final ReadWriteLock lock;
        private volatile double currentAvgResponseTime;
        
        @SuppressWarnings("unchecked")
        public HostStats() {
            this.timeSlots = new Queue[SLOTS_COUNT];
            for (int i = 0; i < SLOTS_COUNT; i++) {
                timeSlots[i] = new ArrayDeque<>();
            }
            this.lock = new ReentrantReadWriteLock();
            this.currentAvgResponseTime = 0;
        }
        
        public void addResponse(long responseTime) {
            int slot = (int) ((System.currentTimeMillis() / 1000) % SLOTS_COUNT);
            ResponseTime rt = new ResponseTime(responseTime);
            
            lock.writeLock().lock();
            try {
                timeSlots[slot].offer(rt);
                updateAvgResponseTime();
            } finally {
                lock.writeLock().unlock();
            }
        }
        
        private void updateAvgResponseTime() {
            long total = 0;
            int count = 0;
            long currentTime = System.currentTimeMillis();
            
            for (Queue<ResponseTime> slot : timeSlots) {
                for (ResponseTime rt : slot) {
                    if (currentTime - rt.timestamp <= WINDOW_SIZE_SECONDS * 1000L) {
                        total += rt.responseTime;
                        count++;
                    }
                }
            }
            
            currentAvgResponseTime = count > 0 ? (double) total / count : 0;
        }
        
        public double getAvgResponseTime() {
            return currentAvgResponseTime;
        }
        
        public void cleanup() {
            lock.writeLock().lock();
            try {
                for (Queue<ResponseTime> slot : timeSlots) {
                    while (!slot.isEmpty() && slot.peek().isExpired()) {
                        slot.poll();
                    }
                }
                updateAvgResponseTime();
            } finally {
                lock.writeLock().unlock();
            }
        }
    }
    
    public LoadBalancer(List<String> hosts) {
        this.hosts = new ArrayList<>(hosts);
        this.hostStats = new ConcurrentHashMap<>();
        this.requestCounter = new AtomicInteger(0);
        
        for (String host : hosts) {
            hostStats.put(host, new HostStats());
        }
    }
    
    public String getNextHost() {
        // Периодическая очистка старых данных
        if (requestCounter.incrementAndGet() % CLEANUP_THRESHOLD == 0) {
            cleanupOldData();
        }
        
        String selectedHost = null;
        double minScore = Double.MAX_VALUE;
        
        for (String host : hosts) {
            HostStats stats = hostStats.get(host);
            double avgResponseTime = stats.getAvgResponseTime();
            
            // Если хост еще не использовался или имеет лучшее время ответа
            if (avgResponseTime == 0) {
                return host;
            }
            
            if (avgResponseTime < minScore) {
                minScore = avgResponseTime;
                selectedHost = host;
            }
        }
        
        return selectedHost;
    }
    
    public void reportResponseTime(String host, long responseTimeMs) {
        HostStats stats = hostStats.get(host);
        if (stats != null) {
            stats.addResponse(responseTimeMs);
        }
    }
    
    private void cleanupOldData() {
        for (HostStats stats : hostStats.values()) {
            stats.cleanup();
        }
    }
    
    public Map<String, Double> getHostsStats() {
        Map<String, Double> stats = new HashMap<>();
        for (Map.Entry<String, HostStats> entry : hostStats.entrySet()) {
            stats.put(entry.getKey(), entry.getValue().getAvgResponseTime());
        }
        return stats;
    }
}
```

Основные улучшения:

1. Использование временных слотов (по секунде) для более эффективного хранения и очистки данных

2. Оптимизация работы с памятью:
   - Циклический буфер для временных слотов
   - Периодическая очистка устаревших данных
   - Эффективное обновление средних значений

3. Улучшенная конкурентность:
   - Использование ReadWriteLock для уменьшения блокировок при чтении
   - ConcurrentHashMap для потокобезопасного доступа к статистике хостов
   - Атомарный счетчик для отслеживания запросов

4. Оптимизация производительности:
   - Кэширование среднего времени ответа
   - Очистка старых данных происходит не при каждом запросе
   - Минимизация блокировок

Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        List<String> hosts = Arrays.asList(
            "server1.example.com",
            "server2.example.com",
            "server3.example.com"
        );
        
        LoadBalancer balancer = new LoadBalancer(hosts);
        
        // Симуляция высокой нагрузки
        ExecutorService executor = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 100000; i++) {
            executor.submit(() -> {
                String host = balancer.getNextHost();
                // Имитация случайного времени ответа
                long responseTime = (long) (Math.random() * 100);
                balancer.reportResponseTime(host, responseTime);
            });
        }
        
        executor.shutdown();
    }
}
```

Эта реализация должна эффективно справляться с нагрузкой в 30000 запросов в секунду, поддерживая актуальную статистику за последние 5 минут.


java import java.util.*; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class LoadBalancer { private static final int WINDOW_SIZE_SECONDS = 300; // 5 минут private static final int SLOTS_COUNT = 300; // По одному слоту на секунду private static final int CLEANUP_THRESHOLD = 1000; // Частота очистки старых данных private final List<String> hosts; private final ConcurrentHashMap<String, HostStats> hostStats; private final AtomicInteger requestCounter; private static class ResponseTime { final long timestamp; final long responseTime; ResponseTime(long responseTime) { this.timestamp = System.currentTimeMillis(); this.responseTime = responseTime; } boolean isExpired() { return System.currentTimeMillis() - timestamp > WINDOW_SIZE_SECONDS * 1000L; } } private static class HostStats { private final Queue<ResponseTime>[] timeSlots; private final ReadWriteLock lock; private volatile double currentAvgResponseTime; @SuppressWarnings("unchecked") public HostStats() { this.timeSlots = new Queue[SLOTS_COUNT]; for (int i = 0; i < SLOTS_COUNT; i++) { timeSlots[i] = new ArrayDeque<>(); } this.lock = new ReentrantReadWriteLock(); this.currentAvgResponseTime = 0; } public void addResponse(long responseTime) { int slot = (int) ((System.currentTimeMillis() / 1000) % SLOTS_COUNT); ResponseTime rt = new ResponseTime(responseTime); lock.writeLock().lock(); try { timeSlots[slot].offer(rt); updateAvgResponseTime(); } finally { lock.writeLock().unlock(); } } private void updateAvgResponseTime() { long total = 0; int count = 0; long currentTime = System.currentTimeMillis(); for (Queue<ResponseTime> slot : timeSlots) { for (ResponseTime rt : slot) { if (currentTime - rt.timestamp <= WINDOW_SIZE_SECONDS * 1000L) { total += rt.responseTime; count++; } } } currentAvgResponseTime = count > 0 ? (double) total / count : 0; } public double getAvgResponseTime() { return currentAvgResponseTime; } public void cleanup() { lock.writeLock().lock(); try { for (Queue<ResponseTime> slot : timeSlots) { while (!slot.isEmpty() && slot.peek().isExpired()) { slot.poll(); } } updateAvgResponseTime(); } finally { lock.writeLock().unlock(); } } } public LoadBalancer(List<String> hosts) { this.hosts = new ArrayList<>(hosts); this.hostStats = new ConcurrentHashMap<>(); this.requestCounter = new AtomicInteger(0); for (String host : hosts) { hostStats.put(host, new HostStats()); } } public String getNextHost() { // Периодическая очистка старых данных if (requestCounter.incrementAndGet() % CLEANUP_THRESHOLD == 0) { cleanupOldData(); } String selectedHost = null; double minScore = Double.MAX_VALUE; for (String host : hosts) { HostStats stats = hostStats.get(host); double avgResponseTime = stats.getAvgResponseTime(); // Если хост еще не использовался или имеет лучшее время ответа if (avgResponseTime == 0) { return host; } if (avgResponseTime < minScore) { minScore = avgResponseTime; selectedHost = host; } } return selectedHost; } public void reportResponseTime(String host, long responseTimeMs) { HostStats stats = hostStats.get(host); if (stats != null) { stats.addResponse(responseTimeMs); } } private void cleanupOldData() { for (HostStats stats : hostStats.values()) { stats.cleanup(); } } public Map<String, Double> getHostsStats() { Map<String, Double> stats = new HashMap<>(); for (Map.Entry<String, HostStats> entry : hostStats.entrySet()) { stats.put(entry.getKey(), entry.getValue().getAvgResponseTime()); } return stats; } } 


java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class LoadBalancer {
    private final List<String> hosts;
    private final Map<String, HostStats> hostStats;
    
    private static class HostStats {
        private double avgResponseTime;
        private int requestCount;
        
        public HostStats() {
            this.avgResponseTime = 0;
            this.requestCount = 0;
        }
        
        public void updateStats(long responseTime) {
            avgResponseTime = (avgResponseTime * requestCount + responseTime) / (requestCount + 1);
            requestCount++;
        }
    }
    
    public LoadBalancer(List<String> hosts) {
        this.hosts = new ArrayList<>(hosts);
        this.hostStats = new ConcurrentHashMap<>();
        
        for (String host : hosts) {
            hostStats.put(host, new HostStats());
        }
    }
    
    public String getNextHost() {
        String selectedHost = null;
        double minScore = Double.MAX_VALUE;
        
        for (String host : hosts) {
            HostStats stats = hostStats.get(host);
            // Вычисляем score на основе среднего времени ответа и количества запросов
            double score = stats.avgResponseTime * (stats.requestCount + 1);
            
            if (score < minScore) {
                minScore = score;
                selectedHost = host;
            }
        }
        
        return selectedHost;
    }
    
    public void reportResponseTime(String host, long responseTimeMs) {
        HostStats stats = hostStats.get(host);
        if (stats != null) {
            stats.updateStats(responseTimeMs);
        }
    }
    
    public Map<String, Double> getHostsStats() {
        Map<String, Double> stats = new HashMap<>();
        for (Map.Entry<String, HostStats> entry : hostStats.entrySet()) {
            stats.put(entry.getKey(), entry.getValue().avgResponseTime);
        }
        return stats;
    }
}
```

Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        // Инициализация балансировщика
        List<String> hosts = Arrays.asList(
            "server1.example.com",
            "server2.example.com",
            "server3.example.com"
        );
        
        LoadBalancer balancer = new LoadBalancer(hosts);
        
        // Получение хоста и отправка статистики
        String host = balancer.getNextHost();
        System.out.println("Selected host: " + host);
        
        // Имитация запроса и отправка времени ответа
        balancer.reportResponseTime(host, 150); // 150ms response time
        
        // Получение статистики
        Map<String, Double> stats = balancer.getHostsStats();
        System.out.println("Current stats: " + stats);
    }
}
